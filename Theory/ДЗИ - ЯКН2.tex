\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathabx}
\usepackage{parskip}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage[bulgarian]{babel}

\definecolor{mGreen}{rgb}{0.41,0.67,0.34}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}

% \lstdefinestyle{CStyle}{
%     backgroundcolor=\color{backgroundColour}, commentstyle=\color{mGreen}, keywordstyle=\color{magenta},
%     numberstyle=\tiny\color{mGray}, stringstyle=\color{mPurple}, basicstyle=\ttfamily ,breakatwhitespace=false, 
%     breaklines=true, captionpos=b, keepspaces=true, numbers=left, numbersep=5pt, showspaces=false, showstringspaces=false,
%     showtabs=false, tabsize=2, language=C
% }
\lstset{language=C++, backgroundcolor=\color{backgroundColour}, commentstyle=\color{magenta}, basicstyle=\ttfamily,
keywordstyle=\color{blue}\ttfamily, stringstyle=\color{red}\ttfamily, numberstyle=\tiny\color{mGray}, captionpos=b,
keepspaces=true, numbers=left, numbersep=5pt, texcl=true}

\begin{document}

\title{Теми за Държавен Изпит}
\author{}
\maketitle

\subsection*{Процедурно програмиране – основни конструкции.}

\textbf{1.\underline{Основни принципи}} \newline\newline
Основните принципи на процедурното програмиране са принципа за модулност и принципа за абстракция на данните. Съгласно принципа
за модулност, програмата се разделя на подходящи взаимосвързани части, всяка от които се реализира чрез определени средства.
Съгласно принципа за абстракция на данните, методите за използване на данните се отделят от методите за тяхното коректно
представяне. Програмите се конструират така, че да работят с абстрактни данни - данни с неуточнено представяне. 

\textbf{2.\underline{Управление на изчислителния процес}} \newline\newline
\textbf{Условни оператори}
Чрез тези оператори се реализират разклоняващи се изчислителни процеси. Оператор, който дава възможност да се изпълни (или не)
един или друг оператор в зависимост от някакво условие, се нарича условен. Примери за условни оператори са: $if, if/else$ и $switch$. \newline\newline
\textbf{If оператор} \newline
\underline{Синтаксис} \newline
$if$ (<условие>) <оператор>, където $if$ е запазена дума, <условие> е булев израз и <оператор> е произволен оператор. \newline
\underline{Семантика} \newline
Пресмята се стойността на булевия израз, представящ условието. Ако резултатът е $true$, изпълнява се <оператор>, в противен случай
не се изпълнява. \newline\newline
\textbf{If/else оператор} \newline
\underline{Синтаксис} \newline
$if$ (<условие>) <оператор1> $else$ <оператор2>, където $if$ и $else$ са запазени думи, <условие> е булев израз и <оператор1> и
<оператор2> са произволни оператори. \newline
\underline{Семантика} \newline
Пресмята се стойността на булевия израз, представящ условието. Ако резултатът е $true$, изпълнява се <оператор1>, в противен случай
се изпълнява <оператор2>. \newline\newline
\textbf{Switch оператор} \newline
\underline{Синтаксис} \newline
$switch$ (<израз>) \newline
$case <\text{израз}_1>$ : $<\text{редица\_от\_оператори}_1>$ \\
\dots \\
$case <\text{израз}_{n-1}>$ : $\text{<редица\_от\_оператори}_{n-1}>$ \\
$[$default : $<\text{редица\_от\_оператори}_n>$], където $switch$, $case$ и $default$ са запазени думи,  \newline
\underline{Семантика} \newline
Намира се стойността на $switch$ израза, получената константа се сравнява последователно със стойностите на етикетите $\text{израз}_1
\text{израз}_2$ и при съвпадение, се изпълняват операторите на съответния вариант и операторите на всички варианти, разположени
след него, до срещане на оператор $break$. В противен случай, ако участва $default$-вариант, се изпълнява редицата от оператори,
която му съответства и в случай, че не участва такъв - не следват никакви действия от оператора $switch$. \newline\newline
\textbf{Оператори за цикъл} \newline
Операторите за цикъл се използват за реализиране на циклични изчислителни процеси. Изчислителен процес, при който оператор или
група от оператори се изпълняват многократно за различни стойности на техни параметри, се нарича цикличен. Съществуват два вида
изчислителни процеси - индуктивни, при които броят на повторенията е известен предварително и итеративни, при които броят на
повторенията не е известен предварително. \newline\newline
\textbf{For оператор} \newline
\underline{Синтаксис} \newline
$for$ (<инициализация>; <условие>; <корекция>) <оператор>, където $for$ е запазена дума, <условие> е булев израз,
<инициализация> е или точно една дефиниция с инициализация на една или повече променливи, или няколко оператора за присвояване
или въвеждане, отделени със , и не завърващи с ;, <корекция> е един или няколко оператора, незавърващи с ; (в случай че са няколко
се отделят със ,) и <оператор> е точно един произволен оператор, който се нарича тяло на цикъла. \newline
\underline{Семантика} \newline
Изпълнението започва с изпълнение на частта <инициализация>. След това се намира стойността на <условие>. Ако в резултат се е
получило $false$, изпълнението на оператора $for$ завършва, без тялото да се е изпълнило нито веднъж. В противен случай последователно\newline\newline
се повтарят следните действия: изпълнение на тялото на цикъла, изпълнение на операторите от частта <корекция>, пресмятане на
стойността на <условие> докато стойността на <условие> е $true$. \newline\newline
\textbf{While оператор} \newline
\underline{Синтаксис} \newline
$while$ (<условие>) <оператор>, където $while$ е запазена дума, <условие> е булев израз и <оператор> е произволен оператор, който
описва действията, които се повтарят и се нарича тяло на цикъла. \newline
\underline{Семантика} \newline
Пресмята се стойността на <условие>. Ако тя е $false$, изпълнението на оператора $while$ завършва без да се е изпълнило тялото му
нито веднъж. В противен случай, изпълнението на <оператор> и пресмятане на стойността на <условие> се повтарят докато <условие>
е $true$. В първия момент, когато <условие> стане $false$, изпълнението на $while$ завършва. \newline\newline
\textbf{Do/while оператор} \newline
\underline{Синтаксис} \newline
$do$ <оператор> \newline $while$ (<условие>), където $do$ и $while$ е запазени думи, <условие> е булев израз и <оператор> е
произволен оператор, който описва действията, които се повтарят и се нарича тяло на цикъла. \newline
\underline{Семантика} \newline
Изпълнява се тялото на цикъла, след което се пресмята стойността на <условие>. Ако то е $false$, изпълнението на оператора
$do/while$ завършва. В противен случай, се повтарят действията: изпълнение на тялото и пресмятане на стойността на <условие>,
докато стойността на <условие> е $true$. Веднага, след като стойността му стане $false$, изпълнението на оператора завършва. \newline\newline
\textbf{3.\underline{Променливи}} \newline\newline
Променливата е място за съхранение на данни, което може да съдържа различни стойности по време на изпълнение на програмата.
Означава се чрез редица от букви, цифри и долна черта, започваща с буква или долна черта. Променливите имат три характеристики:
тип, име и стойност. Преди да бъдат използвани, те трябва да бъдат дефинирани. C++ е строго типизиран език за програмиране.
Всяка променлива има тип, който явно се указва при дефинирането й. \newline\newline
\textbf{Дефиниране на променливи} \newline\newline
\underline{Синтаксис}:
$\text{<име\_на\_тип>}$ <променлива> [ = <израз> ] {, <променлива> [ = <израз> ] };
където $\text{<име\_на\_тип>}$ е дума, означаваща име на тип като int, double и др., а <израз> е правило за получаване на стойност - цяла,
реална, знакова и др. тип, съвместим с $\text{<име\_на\_тип>}$. \newline\newline
\underline{Семантика}:
Дефиницията свързва променливата с множеството от допустимите стойности на типа, от който е променливата или
с конкретна стойност от това множество. За целта се отделя определено количество оперативна памет
(толкова, колкото да се запише най-голямата константа от множеството от допустимите стойности на съответния
тип) и се именува с името на променливата. Тази памет е с неопределено съдържание или съдържа стойността на
указания израз, ако е направена инициализация. Не се допуска една и съща променлива да има няколко дефиниции
в рамките на една и съща функция. \newline\newline
\textbf{Видове променливи}
\begin{itemize}
    \item Локални - променливи, които имат локална област на действие. Те са дефинирани във функции и не са достъпни за кода в
    другите функции на модула. Областта им се определя според общо правило – започва от мястото на дефинирането и завършва в
    края на оператора (блока), в който идентификаторът е дефиниран. Формалните параметри на функциите също имат локална видимост.
    Областта им е тялото на функцията. ??????
    \item Глобални - променливи, които се дефинират извън функциите и които са "видими" за всички функции, дефинирани след тях.
    Декларират се както се дефинират другите (локалните) променливи. Използването на много глобални променливи е лош стил за
    програмиране и не се препоръчва. Всяка глобална променлива трябва да е съпроводена с коментар, обясняващ предназначението й.
\end{itemize}
\textbf{Инициализация на променлива}
????? \newline\newline
\textbf{Оператор за присвояване} \newline\newline
\underline{Синтаксис}:
<променлива> = <израз>; \newline
където <променлива> и <израз> са от един и същ тип. \newline\newline
\underline{Семантика}:
Пресмята стойността на <израз> и я записва в паметта, именувана с променливата от лявата страна на знака за присвояване =. \newline\newline
Пример:
\begin{lstlisting}
a = 1;
b = 2;
c = 2 * (a + b);
\end{lstlisting}
Чрез операторите за присвояване, променливите $a, b$ и $c$ получават текущи стойности. \newline\newline
\textbf{4.\underline{Функции, процедури и параметри}} \newline
Функциите са основни структурни единици, които изграждат програмите на езика. Сред функциите задължително трябва да има точно една
с име $main$, наречена главна функция. Тя е първата функция, която се изпълнява при стартиране на програмата. Използването на
функции има следните предимства:
\begin{itemize}
    \item програмите стават ясни и лесни за тестване и модифициране
    \item избягва се многократно повторение на едни и същи програмни фрагменти, които се дефинират еднократно и могат да се
    изпълняват произволен брой пъти
    \item постига се икономия на памет, тъй като кодът на функцията се съхранява само на едно място в паметта, независимо от броя
    на нейните изпълнения
\end{itemize}

Разпределение на оперативната памет за изпълнима програма \newline

Разпределението на оперативната памет най-общо се състои от: програмен код, област на статичните данни, област на динамичните
данни и програмен стек. В програмният код е записан изпълнимият код на всички функции, изграждащи потребителската програма. В
областта на статичните данни са записани глобалните обекти на програмата. За реализиране на динамични структури от данни се
използват средства за динамично разпределение на паметта. Чрез тях се заделя и освобождава памет в процеса на изпълнение на 
програмата, която е областта на динамичните данни. Програмният стек е вид памет, която съхранява данните на функциите на програмата.
Стекът е динамична структура, организирана по правилото $LIFO$, представляваща редица от елементи с пряк достъп до елементите от
единия си край, наречен връх. Достъпът се реализира чрез указател. Операцията включване се осъществява само пред елемента от върха,
а операцията изключване - само за елементита от върха. Елементите на програмния стек са "блокове" от памет, съхраняващи данни,
дефинирани в някоя функция, които се наричат стекови рамки.

Пример за функция:
\begin{lstlisting}
int gcd(int a, int b) {
    while (a != b) {
        (a > b) ? a = a - b : b = b - a; 
    }
    
    return a;
}
\end{lstlisting}
Двуаргументната функция с име $gcd$, е от тип $int$, а параметрите $a$ и $b$ се наричат формални параметри на функцията. Тялото
и е блок, реализиращ алгоритъма на Евклид за намиране на НОД на две числа, който завършва с оператора $return$. Чрез него се
прекратява изпълнението на функцията като стойността на израза след $return$ се връща като стойност на $gcd$.

\textbf{5.\underline{Символни низове}} \newline\newline
\underline{Логическо описание} \newline
Редица от краен брой символи, заградени в кавички, се нарича символен низ или само низ. Броят на символите в редицата се нарича
дължина на низ. Низ, който се съдържа в друг низ, се нарича негов подниз. Конкатенация на два низа е низ, получен като в края на
първия низ се запише вторият. Два символни низа се сравняват лексикографски - сравнява се всеки символ от първия низ със символа
на другия низ на същата позиция, докато не се намерят два различни символа или до края на поне един от символните низове. Ако
кодът на символ от първия низ е по-малък от кода на съответния символ от втория низ се приема, че първият низ е по-малък от втория. \newline\newline
\underline{Физическо представяне} \newline
В оперативната памет, низовете се представят последователно. Съществуват 2 начина за разглеждане на низовете в езика $C++$:
\begin{itemize}
    \item масиви от символи
    \item указатели към тип $char$
\end{itemize}
Ще разгледаме символните низове като масиви от символи.
\begin{lstlisting}
char str[100]; // дефинира променливата str като масив от 100
// символа
char str2[5] = {'a', 'b', 'c'} // дефинира масив от символи
// str2 и го инициализира, тук тъй като при инициализацията са
// указани по-малко от 5 символа, останалите се допълват с '0'
\end{lstlisting}
Низовете разглеждаме като редица от символи, завършващи с нулевия символ $\backslash0$, наречен още терминираща нула. Предимството
на това е, че не е необходимо за всеки низ да се пази в променлива дължината му, тъй като знакът за края на низ позволява да се
определи краят му. ????

\subsection*{Процедурно програмиране – указатели, масиви и рекурсия.}

\textbf{1.\underline{Указатели и указателна аритметика}} \newline\newline
Тип указател
Променливите са свързани със стойности - неопределени или константи от същия тип, които се наричат $rvalue$. Мястото в паметта,
в което е записана $rvalue$ се нарича адрес на променливата или още $lvalue$. Ако имаме дефиницията $int i = 1024;$, тогава
стойността на променливата $i (rvalue)$ е 1024 и тя именува място от паметта $(lvalue)$ с размери 4 байта, като $lvalue$ е адреса
на първия байт. Намирането на адреса на дефинирана променлива става чрез ундарния префиксен дясноасоциативен оператор $\&$: \newline\newline
\underline{Синтаксис}:
\&<променлива>, където <променлива> е дефинирана променлива \newline\newline
\underline{Семантика}:
Намира адреса на <променлива>. \newline\newline
\textbf{2.\underline{Масиви - основни операции и алгоритми}} \newline\newline
\underline{Логическо описание} \newline
Масивът е крайна редица от фиксиран брой елементи от един и същ тип. Към всеки елемент от редицата е възможен пряк достъп, който
се осъществява чрез индекс. Операциите включване и изключване на елемент в/от масива са недопустими (статична структура от данни). \newline\newline
\underline{Физическо представяне} \newline
Елементите на масива се записват последователно в паметта на компютъра, като за всеки елемент на редицата се отделя определено
количество памет.

\textbf{3.\underline{Рекурсия}} \newline\newline
Функция, която се обръща пряко или косвено към себе си, се нарича рекурсивна. Програма, съдържаща рекурсивна функция е рекурсивна.
Пример:
\begin{lstlisting}
int fact(int n)  { 
    if (n <= 1) return 1;
    return n * fact(n - 1); 
} 
\end{lstlisting}
Рекурсивната функция $fact$, приложена към естествено число, връща факториела на това число. Стойността на функцията се определя
посредством обръщение към самата функция в оператора $return \hspace{0.2cm} n * fact(n - 1)$. Нека проследим хода на рекурсивната функция при
примерно извикване:
\begin{lstlisting}
cout << n << "!=" << fact(n);
\end{lstlisting}

\section*{Обектно-ориентирано програмиране}

\subsection*{ООП. Основни принципи. Класове и обекти. Наследяване и капсулация.}

\textbf{1.\underline{Абстракция със структури от данни. Класове и обекти. Видове конструктори.} \\
\underline{Управление на динамичната памет и ресурсите (RAII). Методи}} \newline\newline
\textbf{Абстракция с данни} е подход, при който методите за използване на данните са разделени от методите за тяхното представяне.
Програмите се конструират така, че да работят с "абстрактни данни" - данни с неуточнено представяне. След това представянето се
конкретизира с помощта на множество функции, наречени конструктори, селектори и предикати, които реализират "абстрактните данни"
по конкретен начин.

\textbf{Класовете} са основни програмни единици в обектно-ориентираните езици, представляващи съвкупност от променливи и функции,
които са обвързани в логическа структура и работят заедно. Те служат като модели за представяне на реални обекти, описвайки
атрибути (свойства) и методи (поведение) на обектите. \newline
\textbf{Декларацията на клас} се състои от заглавие и тяло. Заглавието започва с ключовата дума $class$, следвана от идентификатор,
задаващ името на класа. Тялото съдържа декларации на компонентите на класа (член-данни и член-функции). Декларациите са заградени
във фигурни скоби, следвани от знака $;$ или списък от обекти следван от $;$.

Пример: \begin{lstlisting}
class Date {
    //Тяло на класа
};
\end{lstlisting}
\textbf{Обектите} са екземпляри на даден клас. Връзката между клас и обект е подобна на връзката между тип данни и променлива
величина, но за разлика от обикновените променливи, обектите се състоят от множество компоненти (член-данни и член-функции).
Ако в клас явно не е дефиниран конструктор, \textbf{дефиницията на обект} от този клас не трябва да съдържа инициализация с явно
обръщение към конструктор, т.е. трябва да има вида: $\text{<име\_на\_клас><обект>};$.

Пример: \begin{lstlisting}
Date d;
\end{lstlisting}
В този случай, автоматично в класа се създава
подразбиращ се конструктор и инициализацията на обекта се осъществява чрез него. Този конструктор изпълнява редица действия,
като заделяне на памет за обектите, инициализиране на системни променливи и т.н.

Създаването на обекти е свързано със заделяне на памет, запомняне на текущо състояние, задаване на начални стойности и други
дейности, които се наричат инициализация на обектите. Тя се изпълнява от специален вид член-функции на класовете -
\textbf{конструкторите}. Конструкторът е член-функция, която притежава повечето характеристики на другите член-функции и има
редица особености като:
\begin{itemize}
    \item името на конструктора съвпада с името на класа
    \item типът на резултата не се указва явно
    \item изпълнява се автоматично при създаване на обекти
    \item не може да се извиква явно
\end{itemize}
В клас може явно да не е дефиниран конструктор, но може да са дефинирани и няколко конструктора. Всички те имат едно и също име - 
името на класа, но трябва да се различават по броя и/или типа на параметрите си. Такива конструктори се наричат предефинирани.
При създаването на обект от клас се изпълнява само един от тях. \textbf{Основните видове конструктори} са:
\begin{itemize}
    \item Конструктор по подразбиране
    \item Конструктор с параметри
    \item Конструктор за копиране
\end{itemize}
Ако в даден клас не е дефиниран конструктор, автоматично се създава т.н. конструктор по подразбиране. Той реализира множество от
действия като заделяне на памет за член-данните на обект, инициализиране на системни променливи и др. Този конструктор може да
бъде предефиниран, като за целта е необходимо в класа да бъде дефиниран конструктор без параметри.

Пример: \begin{lstlisting}
date::date() {
    month = 9;
    day = 13;
    year = 2024;
}
\end{lstlisting}
Инициализацията на новосъздаден обект на даден клас може да зависи от друг обект на същия клас. За да се укаже такава зависимост,
се използват операторът за присвояване или кръгли скоби. Конструкторът за присвояване е специален конструктор, който поддържа
формален параметър от тип $const \text{<име\_на\_клас>}\&$. Ако в един клас явно не е дефиниран конструктор за присвояване, компилаторът
автоматично създава такъв, в момента когато новосъздаден обект се инициализира с обект, намиращ се от дясната страна на оператора
за присвояване или кръгли скоби. Този конструктор за присвояване се нарича конструктор за копиране.
Пример: \begin{lstlisting}
date::date(const date& other) {
    month = other.month;
    day = other.day;
    year = other.year;
}
\end{lstlisting}

\textbf{2.\underline{Наследяване. Производни и вложени класове. Капсулация. Статични полета и методи.}} \newline\newline
\textbf{Наследяването} е начин за създаване на нови класове чрез използване на компоненти и поведение на вече съществуващи класове.
Класовете, които са вече дефинирани се наричат базови, а новосъздадените - \textbf{производни}. Производният клас може да наследи
компонентите на един или няколко базови класа. В първия случай наследяването се нарича единично, а във втория - множествено.
Ако множество от класове имат общи член-данни и методи, тези общи части могат да се обособят като основни класове, а всяка от
останалите части да се дефинира като производен клас на съответните основни класове. По този начин се спестява памет, тъй като
се избягва многократното описание на едни и същи програмни фрагменти. При конструирането на производни класове е достатъчно да
се разполага само с обектните модули на основните класове, а не с техния програмен код. Това позволява да бъдат създавани библиотеки
от класове, които да бъдат използвани при създаването на производни класове. Тези предимства, а също и възможността за реализиране
на полиморфизъм, мотивират въвеждането на наследяване и на производни класове. Подобно на обикновените, производните класове се
дефинират, като се декларира класът и се дефинират неговите методи. \newline\newline

Множеството от компонентите на производен клас се състои от компонентите на неговите базови класове и компонентите, декларирани
в самия производен клас. Механизъмът, чрез който производния клас получава компонентите на базовия, се нарича наследяване.
Процесът на наследяване се изразява в следното: ...???? Защо пак обясняваме какво е наследяване

Пример: \begin{lstlisting}
#include <iostream>
#include <cstring>
using namespace std;

// Базов клас
class Person {

    public:
        void readPerson(const char*, const char*);
        void printPerson() const;

    private:
        char* name;
        char* ucn;
};

void Person::readPerson(const char* na, const char* uc) {
    name = new char[strlen(na) + 1];
    strcpy(name, na);

    ucn = new char[strlen(uc) + 1];
    strcpy(ucn, uc);
}

void Person::printPerson() const {
    cout << "Name: " << name << endl;
    cout << "UCN: " << ucn << endl; 
}

// Производен клас
class Student : public Person {
    
    public:
        void readStudent(const char*, const char*, long,
        double);
        void printStudent() const;
    private:
        long FN;
        double gpa;
};

void Student::readStudent(const char* na, const char* uc,
long fn, double g) {
    readPerson(na, uc);
    FN = fn;
    gpa = g;
}

void Student::printStudent() const {
    cout << "Faculty number: " << FN << endl;
    cout << "GPA: " << gpa << endl; 
}

int main() {

    Student s;
    s.readStudent("Ivan Ivanov", "1234567890", 81992, 4.5);
    s.printStudent();

    return 0;
}
\end{lstlisting}

Капсулация
Пред всяко име на базов клас в заглавието на декларацията на производен клас, може да се постави ключовата дума $public, private$
или $protected$. Нарича се атрибут за област, тъй като определя областта на наследените членове. 

\textbf{{Капсулация}} \newline
Механизъм за ограничаване на директния достъп до някои от компонентите на обектите.

\subsection*{ООП. Подтипов и параметричен полиморфизъм. Множествено наследяване.}

\textbf{1.\underline{Виртуални функции и подтипов полиморфизъм. Абстрактни методи и класове.}} \newline

В езика за програмиране $C++$, при извикване на функции с едно и също име, е имплементиран механизъм за разпознаване коя функция
да се изпълни. Той се изразява в следното: по време на компилация се сравняват формалните с фактическите параметри в обръщението
и по правилото за най-добро съвпадане се избира необходимата функция. След заместване на формалните с фактическите параметри,
се изпълнява тялото на функцията. При член-функциите на йерархия от класове конфликтът между имената на наследените и собствените
методи с един и същ тип на резултата и с един и същи типове на явно указаните формални параметри се разрешава също по време на
компилация чрез правилото на локалния приоритет и чрез явно посочване на класа, към който принадлежи методът. В тези два случая,
тъй като разрешаването на конфликтите приключва по време на компилация и не може да бъде променяно по време на изпълнение на
програмата, се казва че се осъществява статично свързване. Езикът поддържа още един механизъм за разрешаване на връзките, наречен
динамично свързване. При него изборът на функция, която трябва да се изпълни, се осъществява по време на изпълнение на програмата.
Динамичното свързване капсулира детайлите в реализацията на йерархията. При него не се налага преобразуване на типове, текстовете
на програмите се опростяват, а промени се налагат много по-рядко. Прилагането на механизма на динамичното свързване се осъществява
над специални член-функции на класове, наречени \textbf{виртуални функции} (методи). Те се декларират чрез поставяне на ключовата
дума $virtual$ пред декларацията им:
\begin{lstlisting}
virtual void print();
\end{lstlisting}

Чисто виртуални функции наричаме функции, които не са дефинирани, а само декларирани. Синтаксисът за тях е следния:
\begin{lstlisting}
virtual void print() = 0;
\end{lstlisting}

\textbf{Полиморфизмът} е важна характеристика на обектно-ориентираното програмиране, която се изразява в това, че едни и същи
действия се реализират по различен начин в зависимост от обектите, над които се прилагат, т.е. действията са полиморфни
(с много форми). Полиморфизмът е свойство на член-функциите на обектите и се реализира чрез виртуални функции. За да се реализира
полиморфно действие, класовете над които то ще се прилага, трябва да имат общ родител, т.е. да бъдат производни на един и същ
клас. В този клас трябва да бъде дефиниран виртуален метод, съответстващ на полиморфното действие. Във всеки от производните
класове този метод може да бъде предефиниран съобразно особеностите на класа. Активирането на полиморфното действие се осъществява
чрез указател към базовия клас или чрез псевдоним на обект на базовия клас. В зависимост от типа на обекта, към който сочи
указателят, ще бъде изпълняван един или друг виртуален метод. Ако класовете, над които ще се реализира полиморфното действие,
нямат общ родител, такъв може да бъде създаден изкуствено чрез дефиниране на т.н. абстрактен клас.

Пример:
\begin{lstlisting}
#include <iostream>
using namespace std;

class Animal {
    public:
        void print() const {
            cout << "Animal\n";
            cout << "None\n";
        }
};

class Dog : public Animal {
    public:
        void print() const {
            cout << "Animal\n";
            cout << "Dog\n";
        }
};

class Cat : public Animal {
    public:
        void print() const {
            cout << "Animal\n";
            cout << "Cat\n";
        }
};

int main() {

    Animal a;
    a.print();
    Dog d;
    d.print();
    Cat c;
    c.print();

    return 0;
}
\end{lstlisting}
Член-функцията $void print() const$ на всеки от класовете извежда общата информация $Animal$ и специфичната за всеки клас
информация - определяща вида на животното. ??? не е добър пример

Клас, в който е декларирана поне една чисто виртуална функция, се нарича \textbf{абстрактен}. Абстрактните класове имат следните
свойства:
\begin{itemize}
    \item не могат да се създават обекти от абстрактен клас, но могат да се дефинират указатели и псевдоними от такъв клас
    \item чисто виртуалните член-функции задължително трябва да бъдат предефинирани в класовете, производни на абстрактния клас
    или да бъдат обявени за чисто виртуални в тях
\end{itemize}
Абстрактните класове са предназначени да са базови на други класове. Полиморфизмът, с помощта на абстрактните класове, позволява
създаването на хетерогенни структури от данни, т.е. елементите на които са от различен тип (това могат да бъдат стек, опашка,
дърво, граф и др.).

Пример:
\begin{lstlisting}
class File {
    public:
        // Чисто виртуална функция
        virtual void open() const = 0;

        // Чисто виртуална функция
        virtual void close() const = 0;
};
\end{lstlisting}

\textbf{2.\underline{Параметричен полиморфизъм. Шаблони на функция и клас.}} \newline



\textbf{3.\underline{Множествено наследяване.}} \newline

Наследяване наричаме множествено, когато производният клас наследява директно повече от един базов клас. Чрез това наследяване
могат да се изграждат програми с мрежова структура. 

\section*{Структури от данни и програмиране}

\subsection*{Структури от данни. Стек, опашка, списък, дърво. Основни операции върху тях. Реализация.}

\textbf{1.\underline{Структури от данни.}} \newline\newline
\textbf{Структура от данни} наричаме организирана информация, която може да бъде описана, създадена и обработена с помощта на
програма. За да се определи една структура от данни, е необходимо да се опише:
\begin{itemize}
    \item логическо описание на структурата - описание на базата на декомпозицията й на по-прости структури и декомпозицията на
    операциите над структурата с по-прости операции
    \item физическо представяне на структурата - описание на методи за представяне на структурата в паметта на компютъра
\end{itemize}
\textbf{2.\underline{Списък.}} \newline\newline
\underline{Логическо описание} \newline
Нека $T$ е даден тип данни. Линеен списък с елементи от тип $T$ е линейна динамична структура от данни. Определя се като крайна
редица от елементи от тип $T$. Един от елементите, например най-левият, се нарича първи, глава или начален елемент. Останалите
елементи на редицата също образуват линеен списък, който се нарича подсписък или опашка на списъка. Над линеен списък могат да се
изпълняват следните операции:\newline
\begin{itemize}
    \item създаване на празен линеен списък
    \item определяне дали линеен списък е празен
    \item добавяне на елемент към линеен списък
    \item премахване на елемент от линеен списък
    \item достъп до елемента на линеен списък
\end{itemize}
Операциите добавяне, отстраняване и достъп се извършват в произволно място на списъка. Операциите премахване и достъп са възможни
само ако списъкът не е празен. Достъпът е пряк само до първия елемент и е последователен до елементите на опашката на списъка.
С цел улесняване на изпълнението на операциите повечето реализации допускат пряк достъп до последния елемент на списъка, както и
до произволен елемент, ако е известен адресът му. \newline\newline
\underline{Физическо представяне} \newline
Използват се главно 2 начина за физическо представяне на линеен списък в паметта на компютъра - последователно и свързано.
Последователното представяне не се използва заради добре развитите средства за динамично разпределение на паметта. Свързаното
представяне може да реализираме върху списък с една или списък с две връзки. ???????\newline
\textbf{3.\underline{Стек.}} \newline\newline
\underline{Логическо описание} \newline
Нека $T$ е даден тип данни. Стек с елементи от тип $T$ е линейна динамична структура от данни. Определя се като крайна редица от
елементи от тип $T$. Единият край на редицата, в случай че тя не е празна, се нарича връх или начало на стека. Стекът се определя
като структура "последен влязъл - пръв излязъл" (Last In First Out - $LIFO$). Над стек могат да се изпълняват следните операции:
\begin{itemize}
    \item създаване на празен стек
    \item определяне дали стек е празен
    \item добавяне на елемент във върха на стек
    \item премахване на елемент от върха на стек, ако той не е празен
    \item достъп до елемента от върха на стек, ако той не е празен
\end{itemize}
\underline{Физическо представяне} \newline
Последователно представяне
При това представяне се запазва блок от паметта, в който стекът да се променя: нараства при добавяне на елементи или намалява
при премахване на елементи. При добавяне на елементи, те се поместват в последователни адреси в неизползваната част веднага след
върха на стека. Тази операция е възможна до пълното изчерпване на неизползваната част. При отстраняване на елементи се променя
указателят към върха на стека. Блокът от паметта, в който се съхранява стекът, се реализира чрез едномерен масив, а указателят
към върха на стека - чрез индекс.
Свързано представяне
При това представяне елементите на стека не се разполагат в последователни адреси в паметта, а са разпръснати на свободни места
в паметта. Реализира се като всеки елемент на стека се представя чрез блок с две полета: информационно (съдържа стойността на
елемента) и адресно (съдържа адреса на предишния елемент на стека). Адресното поле на последния елемент е $NULL$. Добавянето на
елемент се осъществява чрез създаване на нов блок. Премахването на елемент се реализира като в помощна променлива се записва
информационното поле на блока, представящ върха на стека, указателят $start$ се свързва с адреса от адресното поле, след което се
разрушава блока от върха на стека. \newline\newline
\textbf{4.\underline{Опашка.}} \newline\newline
\underline{Логическо описание} \newline
Нека $T$ е даден тип данни. Опашка с елементи от тип $T$ е линейна динамична структура от данни. Определя се като крайна редица
от елементи от тип $T$. Единият край на редицата, в случай че тя не е празна, се нарича глава или начало на опашката, а другият
край се нарича край или задна част на опашката. Опашката се определя като структура "първи влязъл - първи излязъл"
(First In First Out - $FIFO$). Над опашка могат да се изпълняват следните операции:
\begin{itemize}
    \item създаване на празна опашка
    \item определяне дали опашка е празна
    \item добавяне на елемент в само в края на опашката
    \item премахване на елемент само в началото на опашката, ако тя не е празна
    \item достъп до елемента в началото на опашката, ако тя не е празна
\end{itemize}
\underline{Физическо представяне} \newline
Последователно представяне
При това представяне се запазва блок от паметта, в който опашката да се променя: нараства при добавяне на елементи или намалява
при премахване на елементи. Включването на елемент в опашката се осъществява чрез поместването му в последователни адреси в
неизползваната част веднага след края на опашката. Съществуват разновидности на това представяне. Една от тях, която най-често се
използва е цикличното представяне. При него, при изчерпване на масива, ако има свободна памет в началото му, включването се
извършва там. При отстраняване на елементи се променя указателят към началото на опашката и се освобождава паметта, заета от
отстранения елемент. Блокът от паметта, в който се съхранява опашката, се реализира чрез едномерен масив, а указателите към началото
и след края на опашката - чрез индекси.
Свързано представяне
Това представяне е аналогично на свързаното представяне представяне на стек. Елементите на опашката не се разполагат в последователни
адреси в паметта, а са разпръснати на свободни места в паметта. Всеки елемент на опашката се представя чрез блок с две полета:
информационно (съдържащо стойността на елемента) и адресно (съдържащо адреса на следващия елемент от опашката). Адресното поле
на последния елемент е означено чрез константата $NULL$, указателят към началото на опашката е означен с $front$, а указателят
към края й - с $rear$. \newline\newline
\textbf{5.\underline{Дърво.}} \newline\newline
Дърво от тип $T$ е структура от данни, която е или празна, или е образувана от:
\begin{itemize}
    \item данна от тип $T$, наречена корен на двоичното дърво от тип $T$
    \item крайно, възможно празно множество от променлив брой несвързани помежду си елементи $T_1,...,T_n$, които са дървета от
    тип $T$, наречени поддървета на дървото от тип $T$
\end{itemize}
Линейният списък се нарича изродено дърво, защото може да се разглежда като дърво, всеки възел на което има най-много едно поддърво.
Над структурата от данни дърво от тип $T$, могат да се изпълняват следните операции:
\begin{itemize}
    \item достъп до връх
    \item включване и изключване на поддърво
    \item включване и изключване на връх от тип $T$
    \item проверка дали дърво е празно
    \item обхождане на дърво от тип $T$ (в практиката се използват предхождащо и последващо обхождане)
\end{itemize}
????????????????
\underline{Физическо представяне} \newline
Най-често се използва свързано представяне на дърво от тип $T$. За целта се използва линеен списък, представен с една връзка.
При това физическо представяне в един свързан списък се реализират коренът и указателите към поддърветата на дървото от тип $T$. \newline\newline
\textbf{6.\underline{Двоично дърво.}} \newline\newline
\underline{Логическо описание} \newline
Двоично дърво от тип $T$ е структура от данни, която е или празна, или образувана от:
\begin{itemize}
    \item данна от тип $T$, наречена корен на дървото от тип $T$
    \item двоично дърво от тип $T$, наречено ляво поддърво на двоичното дърво от тип $T$
    \item двоично дъро от тип $T$, наречено дясно поддърво на двоичното дърво от тип $T$
\end{itemize}
Над двоично дърво могат да се изпълняват следните операции:
\begin{itemize}
    \item достъп до връх
    \item включване и изключване на връх
    \item проверка дали двоично дърво е празно
    \item обхождане на двоично дърво (осъществява се, че изпълнение на три действия - обработка на корена, обхождане на ляво
    поддърво и обхождане на дясно поддърво)
\end{itemize}
Съществуват шест начина за обхождане на двоично дърво: ляво-корен-дясно, корен-ляво-дясно, ляво-дясно-корен, дясно-корен-ляво,
корен-дясно-ляво и дясно-ляво-корен. Двоично дърво, в което всеки възел, който не е листо, има точно два наследника, се нарича
строго. Ако всички листа на строго двоично дърво са на едно и също ниво, двоичното дърво се нарича пълно. \newline\newline
\underline{Физическо представяне} \newline
Използват се главно 2 начина за физическо представяне на двоично дърво от тип $T$ - свързано и верижно. Свързаното представяне
се реализира чрез указател към кутия с три полета - информационно (стойността на корена) и две адресни (представянията на ляво
поддърво и дясно поддърво). Верижното (последователно) представяне се реализира чрез три масива - за представяне на върховете на
дървото, за адресите на лявото и адресите на дясното поддърво. Ролята на адреси се изпълнява от индекси. $i$-ят елемент на
масива "върхове", съдържа стойността на връх на двоичното дърво, $i$-ят елемент на масива "ляво поддърво" съдържа адреса на
лявото поддърво на поддървото с корен $i$-тия елемент, а $i$-ят елемент на масива "дясно поддърво" - адреса на дясното му поддърво.
Поддържа се указател, който съдържа адреса на корена.
\section*{Функционално програмиране}

\subsection*{Функционално програмиране. Обща характеристика на функционалния стил на програмиране.
Дефиниране и използване на функции. Модели на оценяване. Функции от по-висок ред.}

\textbf{1.\underline{Характеристика на функционалния стил. Основни компоненти.} \\ \underline{Примитивни изрази.
Дефиниране на функции. Оценяване.}} \newline\newline
Функционалното програмиране е начин за съставяне на програми, при който единственото действие е обръщението към функции,
единственият начин за разделяне на програмата на части е въвеждането на име на функция и задаването за това име на израз, който
пресмята стойността на функцията, а единственото правило за композиция е суперпозицията на функции. Тук под функция се разбира
програмна част, която "връща" резултат (по-точно, във функционалното програмиране се работи с т. нар. строги функции, които не
предизвикват никакви странични ефекти, а само връщат стойности). Най-съществени елементи на функционалния стил на програмиране
(по-точно, на програмирането във функционален стил) са дефинирането и използването на функции. Не се използват никакви клетки от
паметта и оператори за присвояване и за цикъл, не се описват действия като предаване на управлението и т.н.
Програмирането във функционален стил се състои от:
\begin{itemize}
    \item дефиниране на функции, които пресмятат (връщат) стойности. При това тези стойности еднозначно се определят от
    стойностите на съответните аргументи (фактически параметри);
    \item прилагане (апликация) на тези функции върху подходящи аргументи, които също могат да бъдат обръщения към функции,
    тъй като всяка функция връща стойност. Затова езиците за ФП се наричат още апликативни езици.
\end{itemize}
\textbf{Предимства} на функционалното програмиране:
\begin{itemize}
    \item може да се извършва лесна проверка и поправка на съответните програми поради липсата на странични ефекти
    \item подходящ при проектирането на езици за програмиране, предназначени за многопроцесорни компютри, в които
    много от пресмятанията се извършват паралелно (поради липсата на странични ефекти не се налага програмистът
    да се грижи за евентуални грешки при синхронизацията, причинени от промени на стойности, извършени в
    неправилен ред);
    \item свойства на функционалните програми могат да бъдат доказвани точно (с математически средства)
\end{itemize}
\textbf{Недостатъци} на функционалното програмиране:
\begin{itemize}
    \item строгата функционалност понякога изисква многократно пресмятане на едни и същи изрази – потенциален проблем, който
    има добри теоретични и практически решения;
    \item използването му при решаване на задачи от процедурен (алгоритмичен) характер е неестествено и често неефективно
\end{itemize}

\textbf{2.\underline{Функции от по-висок ред. Анонимни (ламбда) функции.}} \newline

\textbf{Функция от по-висок ред} се нарича всяка функция, която получава поне една функция като параметър или връща функция
като резултат. Пример 

\textbf{Ламбда нотацията} се използва, когато имаме за цел да използваме директно дадена функция, вместо да я именуваме и дефинираме.
Пример $\backslash m \rightarrow n + m$. В Haskell този вид изрази се наричат \textbf{ламбда изрази}, а функциите дефинирани чрез
тях се наричат \textbf{анонимни функции}.

\subsection*{Функционално програмиране. Списъци. Потоци и отложено оценяване.}

Най-често използванта структура във функционалните езици е \textbf{списъкът}. Той представя редица от (променлив брой)
елементи, принадлежащи на един и същ тип. Записът на списъците в Haskell е следният:
\begin{itemize}
    \item $[\hspace{0.2cm}]$ обозначава празен списък (списък без елементи)
    \item $[e_1...e_n]$ обозначава списък с елементи $e_1...e_n$
\end{itemize}
Друга форма на запис на списъци от числа, знакове и елементи на изброими типове е чрез аритметична последователност:
\begin{itemize}
    \item $[n...m]$ е списъкът $[n, n + 1, ..., m]$
    \item $[n, p, ... m]$ е списъкът, чийто първи два елемента са $n$ и $p$, последният му елемент е $m$ и стъпката на
    нарастване на елементите му е $p - n$ 
\end{itemize}
Конструирането на списъци чрез определяне на техния обхват (List Comprehension) ни дава по-голяма свобода. Синтаксисът е
следният: $[expr\hspace{0.2cm}|\hspace{0.2cm}q_1, ..., q_k]$, където $expr$ е израз, а $q_i$ може да бъде генератор от вида
$p \leftarrow lExp$ или тест (филтър), който е булев израз.

\section*{Логическо програмиране}

\subsection*{Синтаксис и семантика на термовете и формулите на предикатното смятане от първи ред. Унификация.}

\textbf{\underline{Дефиниция}} \textbf{Терм} в $\mathcal{L}$ дефинираме индуктивно:
\begin{itemize}
    \item индивидните променливи са термове от $\mathcal{L}$
    \item индивидните константи са термове от $\mathcal{L}$
    \item ако $f \in \mathcal{F}, I(f) = n$, $\tau_1 ... \tau_n$ са термове, то думата $f(\tau_1 ... \tau_n)$ е терм от $\mathcal{L}$
\end{itemize}
\textbf{\underline{Дефиниция}} \textbf{Предикатна формула} в $\mathcal{L}$ дефинираме индуктивно:
\begin{itemize}
    \item ако $p \in \mathcal{P}, I(p) = n, \tau_1 ... \tau_n$ са термове, то $p(\tau_1 ... \tau_n)$ е предикатна формула от $\mathcal{L}$
    \item ако $f_1$ и $f_2$ са формули, то $\neg f_1, f_1 \& f_2, f_1 \vee f_2, f_1 \implies f_2, f_1 \iff f_2$ 
    \item ако $f$ е предикатна формула и $x$ е индивидна променлива, то $\forall xf$ и $\exists xf$ са предикатни формули
\end{itemize}
\textbf{\underline{Дефиниция}}
\textbf{Субституция} наричаме крайно множество от вида $\{x_1/\tau...x_n/\tau\}$ за $x_1...x_n \in Var$ различни помежду си,
$\tau_1,...,\tau_n \in \tau_{\mathcal{L}}$ и $x_i \neq \tau_i, i \in \{1,...,n\}$\newline\newline
\textbf{\underline{Дефиниция}}
Нека $E \neq \varnothing$ е множество от термове, а $\sigma$ е субституция. Казваме, че $\sigma$ е \textbf{унификатор}
за $E$, ако всеки път, когато $\tau_1, \tau_2 \in E$, то $\tau_1\sigma = \tau_2\sigma$, т.е. $E = \{\tau\sigma |
\tau \in E\}$ е синглетон. \newline\newline
\textbf{\underline{Дефиниция}}
Нека $E \neq \varnothing$ е множество от термове. Казваме, че субституцията $\sigma$ е \textbf{най-общ унификатор} за $E$, ако:
\begin{itemize}
    \item $\sigma$ е унификатор за $E$
    \item всеки път когато $\xi$ е унификатор за $E$, то $\exists \eta$ - субституция, такава че $\xi =
    \sigma\eta$
\end{itemize}
\textbf{\underline{Алгоритъм} (намиране на НОУ)}\newline

Нека $\mathcal{L}$ е език на предикатното смятане от първи ред. \newline\newline
\textbf{\underline{Дефиниция}}
\textbf{Структура} за $\mathcal{L}$ наричаме наредената двойка
$\mathcal{A} = <A, I>$, където:
\begin{itemize}
    \item $A \neq \varnothing$ е универсум
    \item $I$ е интерпретация, при която:
    \begin{itemize}
        \item $I(c) = c^{\mathcal{A}} \in A$
        \item $I(p) = p^{\mathcal{A}} \subseteq A \bigtimes ... \bigtimes A = A^{\#p}, p = Pred_{\mathcal{L}}, p^{\mathcal{A}}
        : A^{\#p} \rightarrow \{T, F\}$
        \item $I(f) = f^{\mathcal{A}} : A^{\#f} \rightarrow A, f \in Func_{\mathcal{L}} $
    \end{itemize}
\end{itemize}
\textbf{\underline{Дефиниция}}
Нека $\mathcal{A}$ е структура за $\mathcal{L}$. \textbf{Оценка} на $v$ в $\mathcal{A}$ наричаме изображението $v : Var
\rightarrow A$, т.е. $v(x) \in A$ \newline\newline
\textbf{\underline{Дефиниция}}
Нека $\mathcal{A}$ е структура за $\mathcal{L}$ и $v$ е оценка от $\mathcal{A}$. За всеки терм стойността му в $\mathcal{A}$
при оценката $v$ бележим така: $||\tau||^{\mathcal{A}}[v]$ или $\tau^{\mathcal{A}}[v]$ \newline\newline
\textbf{\underline{Дефиниция}}
Нека $\varphi \in F_{\alpha}$. Казваме, че $\varphi$ е \textbf{изпълнима}, ако съществува структура $\mathcal{A}$ и оценка $v$
такава, че $\mathcal{A} \models_v \varphi$. Ако $\Gamma$ е множество от формули над $\mathcal{L}$, то $\Gamma$ е \textbf{изпълнимо},
ако съществува структура $\mathcal{A}$ и оценка $v$ такава, че $(\forall \psi \in \Gamma)[\mathcal{A} \models_{v} \psi]$ \newline\newline
\textbf{\underline{Дефиниция}}
Казваме, че формулата $\varphi$ има \textbf{модел}, ако има структура $\mathcal{A}$ такава, че $\mathcal{A} \models \varphi$
(т.е. при всяка оценка в $\mathcal{A}$). Казваме, че множество от формули $\Gamma$ има \textbf{модел}, ако има структура
$\mathcal{A}$ такава, че $\mathcal{A} \models \Gamma \iff (\forall \psi \in \Gamma)[\mathcal{A} \models \psi]$ \newline\newline
\textbf{\underline{Дефиниция}}
Казваме, че формулата $\varphi$ е \textbf{затворена}, ако $Var^{free}[\varphi] = \varnothing$ \newline\newline
\textbf{\underline{Дефиниция}}
Казваме, че формулата $\varphi$ е в \textbf{ПНФ}, ако $\varphi = \underbrace{Q_1x_1...Q_nx_n}_\text{кванторен префикс}\Theta$,
където $Q_1...Q_n$ са квантори, а $x_1...x_n$ са две по две различни променливи. \newline\newline
\textbf{\underline{Дефиниция}}
Казваме, че формулата $\varphi$ е \textbf{универсална}, ако $\varphi$ е в ПНФ и кванторния префикс има само квантори за
всеобщност. \newline\newline
\textbf{\underline{Дефиниция}}
Казваме, че съждителна формула е \textbf{вярна при булева интерпретация} $I_0$, ако $I(\varphi) = \tau$, където $I$ е
единственото продължение на $I_0$ от $PVAR$ до множеството от всички съждителни формули $(I_0 \models^{\delta} \varphi \iff
I(\varphi) = \tau)$ \newline\newline
\textbf{\underline{Дефиниция}}
Нека $\Delta$ е множество от формули. Казваме, че $\Delta$ е \textbf{булево изпълнимо}, ако има интерпретация $I_0$, която е
булев модел за $\Delta$, т.е. за всяка формула $\varphi$ от $\Delta$ е в сила, че $I_0 \models^{\delta} \varphi$ (бележим с
$I_0 \models^{\delta} \Delta$) \newline\newline
\textbf{\underline{Дефиниция}}
Нека $\varphi$ е затворена формула в ПНФ, $\varphi = \forall x_1...\forall x_n \Theta$, т.е. е универсална и безкванторна за
$\Theta$. Нека $\tau_1,...,\tau_n \in \tau_{\mathcal{L}}$. Формулата $\Theta[x_1/\tau_1,...,x_n/\tau_n]$ се нарича
\textbf{затворен частен случай} на $\varphi$. \newline $S_i(\Gamma) = \bigcup_{\varphi \in \Gamma}S_i(\varphi) = \bigcup_{\varphi \in
\Gamma} \{\Theta[x_1/\tau_1,...,x_n/\tau_n] \hspace{0.2cm} | \hspace{0.2cm} \varphi = \forall x_1...\forall x_n\Theta, \Theta
\text{ е безкв. формула}\}$ \newline\newline
\textbf{\underline{Теорема}} \newline
Нека $\Gamma$ е множество от затворени универсални формули над $\mathcal{L}$ - език от първи ред. Тогава $\Gamma$ има модел
$\iff S_i(\Gamma)$ е булево изпълнимо
\subsection*{Mетод на резолюцията в съждителното и в предикатното смятане от първи ред. Хорнови клаузи.}
\textbf{\underline{Дефиниция}}
\textbf{Съждителен литерал} наричаме съждителна променлива $p$ или съждителна формула $\neg p, p \in PVAR$ \newline\newline
\textbf{\underline{Дефиниция}}
\textbf{Съждителен дизюнкт} наричаме крайно множество от съждителни литерали. Празният дизюнкт означаваме с
$\blacksquare = \{\}$ \newline\newline
\textbf{\underline{Дефиниция}}
Дизюнктът $D$ е \textbf{резолвента} на $D_1$ и $D_2$, ако $\exists L$ - литерал, такъв че $D = Res_L(D_1, D_2)$. \newline\newline
\textbf{\underline{Дефиниция}}
Нека $S$ е множество от съждителни дизюнкти. \textbf{Резолютивен извод} от $S$ наричаме крайна редица $D_0...D_r$ от
дизюнкти, така че $D_0, D_1 \in S$ и $1 < i \le n : D_i$
\begin{itemize}
    \item $\in S$
    \item $\exists j, k: 0 \le j < k < i$ и има $h \in D_j$ и $h^{\partial} \in D_k$ и $D_i = R_L(D_j, D_k)$
\end{itemize}
\textbf{\underline{Теорема} (Коректност на резолютивна изводимост)} \newline
Нека $S$ е множество от дизюнкти. Ако $S \stackrel{r}{\vdash} \blacksquare$, то $S$ е неизпълнимо.
\begin{proof}
$S \stackrel{r}{\vdash} \blacksquare \iff \blacksquare \in S^* \iff S$ е неизпълнимо $\iff S$ е неизпълнимо
\end{proof}
\textbf{\underline{Лема}} \newline
Нека $S^*$ е множество от съждителни дизюнкти, което е затворено относно правилото за резолюцията. Ако $\blacksquare \notin S^*$,
то $S$ е изпълнимо. \newline\newline
\textbf{\underline{Теорема} (Пълнота на резолютивна изводимост)} \newline
Нека $S$ е множество от дизюнкти. Ако $S$ е неизпълнимо, то $S \stackrel{r}{\vdash} \blacksquare$.
\begin{proof}
Допускаме, че $S$ е неизпълнимо, но $S \stackrel{r}{\vdash} \blacksquare$. Тогава имаме, че $S \stackrel{r}
{\nvdash} \blacksquare \iff \blacksquare \notin S^*$ и от лемата следва, че $S$ е изпълнимо. Абсурд.
\end{proof}
\textbf{\underline{Метод на резолюцията}} \newline
1. Привеждаме формулата в отрицателна нормална форма \newline
2. Привеждаме формулата в пренексна нормална форма \newline
3. Привеждаме формулата в Скулемова нормална форма \newline
3. Привеждаме формулата в конюктивна нормална форма \newline\newline
\textbf{\underline{Дефиниция}}
Един дизюнкт наричаме \textbf{Хорнов}, ако съдържа не повече от един положителен литерал
\begin{itemize}
    \item $\{p\}$ - факт
    \item $\{p, \neg q_1, ..., \neg q_n\}$ - правило, $n > 0$
    \item $\{\neg q_1, ..., \neg q_n\}$ - цел, $n > 0$
\end{itemize}
\textbf{\underline{Теорема}} \newline
Изпълнимите множества от Хорнови дизюнкти имат най-малък модел
\begin{proof}
Нека $P_0 \def \cap_{I \in M}P_i$ е множество от променливи. 
\end{proof}

\end{document}